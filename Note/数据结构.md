# 数据结构

伪代码不关心实现的细节，一个算法要考虑时间复杂度和空间复杂度，大O表示最小的上界，下界是最大的下界。

## 关于手写代码

只需要写出函数/方法即可，不需要加入main函数，#define尽量不用。

## 复杂度分析

### 时间复杂度

算法中基本操作的执行次数作为算法时间复杂度的度量，时间复杂度不是执行完一段程序的总时间，而是其中基本操作的总次数，时间复杂度从快到慢比较关系如下。

1. O(1)
2. O(logn)
3. O(n)
4. O(nlogn)
5. O(n^2)
6. O(n^3)
7. O(n^k)
8. O(2^n)

### 空间复杂度

算法的空间复杂度是指算法在运行所需要的存储空间的度量，主要考虑算法在运行过程中临时占用的存储空间大小，量级和时间复杂度一样。

### 算法复杂度分析

## 数据结构基本概念

1. 数据：数据元素是客观事物的符号表示，所有能输入到计算机中并且背计算机程序处理的符号总称，例如整数、实数和字符串都是数据。
2. 数据元素：数据元素是数据的基本单位，在计算机程序中通常将其作为一个整体进行考虑和处理，有时，一个数据元素可以由若干个数据项组成。
3. 数据项：数据项是数据结构中讨论的最小单位，是数据记录中最基本的、不可分的数据单位。
4. 数据对象：数据对象是性质相同的数据元素的集合，是数据的一个子集。
5. 数据结构
   1. 逻辑结构
   2. 存储结构
   3. 数据的运算
6. 数据结构的逻辑结构
   1. 线性结构：线性结构是一个数据元素的有序(次序)集合，线性结构是指数据之间存在着一对一的线性关系数据结构。
      1. 集合中存在唯一的一个"第一个元素"
      2. 集合中存在唯一的一个"最后一个元素"
      3. 除最后一个元素之外，其他数据元素均有唯一的后继
      4. 除第一个元素之外，其他数据元素均有唯一前驱
   2. 非线性结构：特点是一对多。
      1. 树形结构
      2. 图形结构
7. 数据的物理结构
   1. 顺序存储方法：逻辑上相邻节点存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现。
   2. 链式存储方法：不要求逻辑上相邻的节点在物理位置上也相邻，结点间的逻辑关系是由附加的指针字段表示的。
   3. 索引存储方法：索引存储方法在存储结点信息之外，还要建立附加的索引表来标识结点的地址，索引项的一般形式是<关键字,地址>，关键字标识唯一一个结点，地址作为指向结点的指针。
   4. 散列存储方法：根据结点的关键字通过散列函数之间计算出该结点的存储地址，这抓存储方法本质上是顺序存储方法的扩展。

数据元素之间的关系在计算机中有两种不同的表示方法：顺序映像和非顺序映像，对应的存储结构分别是顺序存储结构和链式存储结构。顺序存储结构是指借助数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系，非顺序映像是指借助指针表示数据元素之间的逻辑关系。

## 算法基本概念

### 算法特性

算法就是任何良定义的计算过程，该过程取某个值或值的集合作为输入，并且产生某个值或值的集合作为输出，也可以理解为由基本运算及规定的运算顺序所构成的完整解题步骤。

1. 有穷性：一个算法必须保证执行有限步骤。
2. 确定性：算法的每一步骤必须有确定的定义。
3. 输入：一个算法有0个或多个输入，以刻画运算对象的初始情况。所谓0个输入是指算法本身确定了初始条件。
4. 输出：一个算法至少一个输出或多个输出，以反映对输入数据加工后的结果，没有输出的算法毫无意义。
5. 可行性：算法中所有操作都必须可以通过已经实现的基本操作进行运算，并且在有限次内实现，而且人们用笔和纸做有限次运算后也可以完成。

### 算法设计目标

1. 正确性
2. 可读性
3. 健壮性
4. 算法效率

### 递归和循环

## 线性表

### 线性表定义

线性表是具有相同特性数据元素的一个有限序列，序列中的个数就是表的长度，用n表示的话，就是n>=0，n可以为0，表示线性表是一个空表。

线性表的逻辑结构是只有队头队尾，队头前没有元素，队尾后没有元素，其他在队中的元素都有一个直接前驱，都一个有直接后继。

### 线性表存储结构

1. 顺序存储结构：顺序表
   1. 随机访问特性
   2. 占用连续存储空间
   3. 存储分配只能提前分配，分配好了以后不能改变。
2. 链式存储结构：链表
   1. 不支持随机访问。
   2. 结点存储空间利用率比较低。
   3. 动态分配，比较灵活。

### 顺序表

表中所有元素都按逻辑顺序，依次存储在指定的存储位置，在一块连续的存储位置中，数组就是一个顺序表。

### 链表

在链表存储中，每个结点不仅包括存储元素的信息，还包括元素之间的逻辑关系，如单链表中前驱结点包含后继结点的地址信息，这样就可以通过前驱结点中的地址信息找到后继结点的位置。

### 链表分类

1. 单链表
   1. 带头结点的单链表
   2. 不带头结点的单链表
2. 双链表
3. 循环单链表
4. 循环双链表
5. 静态链表

## 栈和队列

### 栈

栈是一种只能在一端进行插入或删除只是的线性表，其中允许进行插入或删除的一段被称为栈顶，另一头称为栈底，栈底固定不变，栈的插入和删除一般称为入栈和出栈，栈的特性是先进后出FILO。

### 栈的存储结构

- 顺序表实现栈：顺序栈
- 链表实现栈：链表栈

### 栈的数学性质

当n个元素以某种顺序进栈的时候，并且可以在任何时刻出栈的时候，所获得元素排列数目N满足下面函数的计算。
$$
N = \frac{1}{n+1}C{n \choose 2n}
$$


### 队列

队列是一种受限的线性表，限制在表的一端插入，一段删除，插入的称为队尾，删除的称为队头，插入新元素的操作称为入队，新元素入队以后称为新的队尾元素，从队列中删除的元素称为出队，队列的特性是先进先出FIFO，可以用顺序表和链表来实现。

### 队列的实现

- 顺序表实现队列：顺序队
- 链表实现队列：链队

### 循环队列

在顺序队中，通常让尾指针rear指向刚进队的元素位置，让队首指针front指向刚出队的元素位置，所以元素进队的时候，rear要像后移动，元素出队的时候，front也要向后移动。

### 循环队列状态

- 队空状态
- 队满状态

## 串

### 串的定义

串是由零个或多个字符组成的有限序列，串中字符的个数称为串的长度，含有零个元素的串叫空串，串中任意连续的字符组成的子序列称为该串的子串，包含子串的串称为主串，某个字符在串中的序号称为这个字符的位置，通常用子串第一个字符的位置作为子串在串的位置，要注意的是，空格也是串字符集合的一个元素，由一个或多个空格组成的串称为空格串，串是限定元素为字符的线性表，区别在于线性表操作主要针对表内某一元素，串操作主要针对串内某一子串。

### 串的存储结构

如果直接扫描一个串得出串长的话，时间复杂度是O(n)，而用一个额外空间的话，就是O(1)。

```c
//定长顺顺序存储表示结构体
const int maxSize = 10000;
typedef struct{

    char str[maxSize + 1]; //+1是因为串的结尾有一个'\0'作为标记，串的长度要比数组长度少1，前提是同样的内容。
     char *ch;
    int length;
} Str;
```

### 串的基本操作

1. 赋值操作
2. 取串长度操作
3. 取比较操作
4. 串连接操作
5. 求子串操作
6. 串清空操作

赋值操作和普通的赋值操作不同，因为字符串是一个数组，所以将一个数组的值传给另一个数组，必须对数组中每个元素进行逐一赋值操作，串的比较是串排序应用中的核心操作，比如在单词的字典排序中，需要通过串的比较操作来确定一个单词在字典中的位置，比较操作 如果a的ASCII码 < b的ASCII码，则返回a < b标 如果a的ASCII码 > b的ASCII码，则返回 a > b标记，相等的话，就按照之前条件比较两串中下一对字符。

#### 一个串有多少种子串？

计算公式如下
$$
n*(n+1) / 2 +1
$$


## 串的模式匹配算法

### 简单串匹配算法

对一个串的某个子串定位操作，称为串的模式匹配，其中待定位的子串称为模式串，基本思想是从主串第一个元素和模式串第一个元素做对比，如果相等，就继续往后比较，否则的话，就从主串的第二个开始，以此类推，直到完全匹配，匹配成功返回模式串在主串的位置，匹配失败，则返回一个可区别于主串所谓位置的标记，比如0。

### KMP算法

## 数组、矩阵和广义表

三种数据结构属于线性结构，数组一般采用顺序存储，二维数组要考虑行优先或列优先。

### 特殊矩阵和稀疏矩阵

常见的特殊矩阵

- 对称矩阵：矩阵中元素满足ai,j = aj,i的矩阵被称为堆成矩阵，主对角线上下方元素相等。
- 三角矩阵：只需要存储对角线以及其以下部分的元素和其上三角中的一个元素c即可。
  - 上三角矩阵为矩阵下三角部分，不包括对角线，元素全为c的矩阵。
  - 下三角矩阵为矩阵上三角部分，不包括对角线，元素全为c的矩阵。
- 稀疏矩阵：稀疏矩阵中相同元素c在矩阵中分布不像在特殊矩阵中那么有规律可循，所以必须要设计一些特殊的存储结构
  - 三元组表示法：三元组数据结构为一个长度为n，表内每个元素都有3个分量的线性表，其三个分量分别为值，行下标和列下标。
  - 伪地址表示法：伪地址即元素在矩阵中按照行优先或列优先存储的相对位置，伪地址和三元组表示法的区别在于，三元组表示法每一行中有两个存储单元存放地址，伪地址只需要一个，因为伪地址每一行只有2个存储单元，一个存储矩阵元素值，另一个存放伪地址。

### 稀疏矩阵存储方法

- 邻接表表示法：邻接表表示法将矩阵中每一行的非零元素串成一个链表，链表中有两个分量，分辨表示该节点对应的元素值以及列号。
- 十字链表表示法：矩阵的每一行用一个带头结点结构的链表表示，每一列也用一个带头结点结构的链表表示，这种存储结构中的链表节点有5个分量，行分量，列分量，数据域分量，指向下方结点的指针，指向右方结点的指针。

### 广义表

广义表可以是原子或广义表的一种线性表扩展结构，广义表的长度是最上层元素的个数，比如C = (b,(c,d))长度为2，广义表深度为表中括号最大层数，求深度的时候需要将子表展开，比如广义表D = (B,C) D展开为((d,e),(b,(c,d)))深度为3。

广义表的表头(head)和表尾(tail)：当广义表非空的时候，第一个元素作为为广义表的表头，其余元素组成的表是广义表的表尾。 

## 树与二叉树

### 树的定义

数是一种非线性的数据结构，是多个节点的集合，由唯一的根和若干棵互不交互的子树组成，其中每一棵子树都是一棵树，性质和之前一样。树的结点数目可以为0，为0的时候这棵树称为空树，属于特殊情况。

- 结点：结点不但包括数据元素，而且还包含指向子树的分支。
- 结点的度：结点拥有的子树个数或分支个数。
- 树的度：树中各结点的最大度。
- 叶子结点(终端结点)：度为0的结点。
- 非终端结点(分支节点)：指度不为0的结点，除了根节点之外的非终端结点，也叫内部结点。
- 孩子：结点子树的根。
- 双亲：与孩子定义对应。
- 兄弟：同一个双亲结点的孩子结点。
- 祖先：从根到某结点的路径上的所有结点。
- 子孙：以某节点为根的子树中所有的结点。
- 层次：从根开始，根算第一层，根的子树算第二层，以此类推。
- 树的高度或深度：树中结点的最大层次。
  - 结点的深度是从根结点到该结点路径上的结点个数。
  - 高度是指从某节点往下走可能到达
- 堂兄弟：双亲在同一层的结点互为堂兄弟。
- 有序树：树中结点的子树从左到右是有次序，不能交换。
- 无序树：书中结点的子树没有顺序，可以任意交换，这样的树叫无序树。
- 丰满树：又称理想平衡树，除最底层外，其他层都是满的。
- 森林：诺干个互不相交的树的集合。

### 树的存储结构

1. 顺序存储结构：使用一维数组实现，数组下标表示树的结点，数组中的元素内容表示该节点的双亲结点，结点下标和结点内容之间的关系，可以表示为一棵树。
2. 链式存储结构：
   1. 孩子存储结构
   2. 孩子兄弟存储结构

### 二叉树

在树的基础上再加两个限制条件就可以得到二叉树

1. 每个结点最多两棵子树，二叉树中结点只能是0,1,2
2. 子树有左右顺序之分，不能颠倒
3. 二叉树5种基本形态
   1. 空二叉树
   2. 只有根节点
   3. 只有左子树，右子树为空。
   4. 只有右子树，左子树为空。
   5. 既有左子树，又有右子树。

### 满二叉树和完全二叉树

在一棵二叉树中，如果所有的分支节点都有左孩子和右孩子结点，并且叶子节点都集中在二叉树的最下一层，这样的二叉树称为满二叉树。

如果对一棵深度为k、有n个结点的二叉树进行编号以后，各结点的编号与深度为k的满二叉树中相同位置上结点的编号相同，则是完全二叉树。

### 二叉树主要性质

1. 性质1：非空二叉树上叶子节点数等于双分支节点数加1。

2. 性质2：二叉树的第i层上最多有2^i-1(i>=1)个结点。

3. 性质3：高度或深度为k的二叉树最多有2^k-1(k>=1)个结点，换句话来说，满二叉树中前k层的结点个数为2^k-1

4. 性质4：有n个结点的完全二叉树，对各结点从上到下，从左到右依次编号，则结点之间的关系如下

   1. 如果i为某节点a的编号，则：
      1. 如果i不等于1，则a的双亲结点的编号为(i/2)
      2. 如果2i<=n，则a左孩子的编号为2i；如果2i>n，则a无左孩子。
      3. ​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +
      4. 如果2i+1<=n，则a右孩子的编号为2i+1；如果2i+1>n，则a无右孩子。

5. 性质5：给定n个结点，能构成h(n)种不同的二叉树。卡特兰数
   $$
   h(n) = \frac{C^n_{2n}}{n+1}
   $$
   
6. 性质6：具有n(n >=1)个结点的完全二叉树的高度或深度，为Log2n+1

### 二叉树存储结构

1. 顺序存储结构：顺序存储结构用一个数组来存储一颗二叉树，适合完全二叉树，存储一般类型的二叉树容易造成空间浪费。
2. 链式存储结构：不便于存储任意形态的二叉树，因为二叉树是一个根节点和两棵子树之间的关系，所以设计出一个数据域和两个指针域的链式结点结构。

### 二叉树遍历算法

1. 前序遍历
2. 中序遍历
3. 后序遍历
4. 层次遍历

### 先序遍历

如果二叉树为空，直接返回，什么都不做，不为空的话，就是根节点，左子树，右子树。

```c
void preorder(BTNode *p){
    if(p == NULL) return;
    printf("%d\n", &p->data); //输出根节点;
    preorder(p->lchild);
    preorder(p->rchild);
}
```

### 中序遍历

如果二叉树为空，直接返回，什么都不做，不为空的话，左子树，根节点，右子树。

```c
void inorder(BTNode *p){
    if(p == NULL) return;
    inorder(p->lchild);
    printf("%d\n", p->data);
    inorder(p->rchild);
}
```

### 后序遍历

如果二叉树为空，直接返回，什么都不做，不为空的话，左子树，右子树，根节点。

```c
void postorder(BTNode *p){
    if(p == NULL) return;
    postorder(p->lchild);
    postorder(p->rchild);
    printf("%d\n", p->data);
}

```

前序遍历和中序遍历，中序遍历和后序遍历都可以唯一确定这颗二叉树，但是前后遍历不行，逆后序遍历序列只不过是对先序遍历过程中对左右子树遍历顺序交换所得到的结果。

### 层序遍历

按照二叉树的层次顺序，对二叉树中各个结点访问，根据情况选择至左向右，自右向左，进行层次遍历，需要建立一个循环队列，先将二叉树头节点入队，然后出队，访问该节点，如果有它有左子树，则将右子树的根节点入队，如果它有右子树，则将左子树的根节点入队。然后出队列，对出队结点访问，反复如此，直到队列为空。

```c
void level(BTNode *p){
    int front, rear;
    BTNode *queue[maxSize]; //定义一个循环队列
    front = rear = 0;
    BTNode *q;
    if(p != NULL){
        rear = (rear + 1) % maxSize;
        queue[rear] = p; //根节点入队
        while(front != rear){ //当队列不为空的时候进行循环
            front = (front + 1) % maxSize;
            q = queue[front]; //队头结点出队
            printf("%d\n", q); //访问队头结点
            if(q->lchild != NULL){ //如果左子树不空，则左子树的根节点入队
                rear = (rear + !) % maxSize;
                queue[rear] = q->lchild;
            }
            if(q->rchild != NULL){ //如果右子树不空，则右子树的根节点入队
                rear = (rear + 1) % maxSize;
                queue[rear] = q->rchild;
            }
        }
    }
}
```

### 非递归遍历算法

```c
typedef struct BTNode{
    char data;
    BTNode *lchild;
    BTNode *rchild;
} BTNode;

void preoderNonrecursion(BTNode *bt){
    
    if(bt != NULL){

        BTNode *Stack[maxSize];//定义一个栈
        int top = -1; //初始化栈
        BTNode *p;
        Stack[++top] = bt;//根节点入栈
        while(top != -1){ //栈空循环退出,遍历结束
            p = Stack[top--];
            printf("%d\n", p->data);
            if(p->rchild != NULL)
                Stack[++top] = p->rchild;
            if(p->lchild != NULL)
                Stack[++top] = p->lchild;
        }
    }
}

void inorderNonrecursion(BTNode *bt){
    if(bt != NULL){
        BTNode *Stack[maxSize];
        int top = -1;
        BTNode *p;
        p = bt;
        while(top != -1 || p != NULL){ //左孩子存在,则右孩子入栈
            while(p!=NULL){
                Stack[++top] = p;
                p = p->lchild;
            }
            if(top != -1){ //在栈不空的情况下出栈并输出栈结点
                p = Stack[top--];
                printf("%d\n", p->data);
                p = p->rchild;
            }
        }
    }
}

void postorderNonrecursion(BTNode *bt){
    if(bt != NULL){
        /*定义两个栈*/
        BTNode *Stack1[maxSize];
        int top1 = -1;
        BTNode *Stack2[maxSize];
        int top2 = -1;
        BTNode *p = NULL;
        Stack1[++top1] = bt;
        while(top1 != -1){
            p = Stack1[top1--];
            Stack2[++top2] = p;
            if(p->lchild != NULL){
                Stack1[++top1] = p->lchild;
            }
            if(p->rchild != NULL){
                Stack1[++top1] = p->rchild;
            }
        }
        while(top2 != -1){
            p = Stack2[top2--];
            printf("%d\n", p->data);
        }
    }
}
```

### 线索二叉树

在二叉树线索化的过程中会把树中的空指针利用起来作为寻找当前结点前驱或后继的线索，这样就出现了一个问题，即线索和树中原来指向孩子结点的指针无法区分，为此设计两类指针ltag和rtag，两者为标识域。

- ltag = 0，则表示lchild为指针，指向结点的左孩子，如果ltag = 1，则表示lchild为线索，指向结点的直接前驱。
- rtag = 0，则表示rchild为指针，指向结点的右孩子，如果rtag = 1，则表示rchild为线索，指向结点的直接后继。

对一个二叉树中所有节点的空指针域按照某种遍历方法加线索的过程叫做线索化，被线索化的二叉树被称为线索二叉树。

### 线索二叉树分类

1. 前序线索二叉树
2. 中序线索二叉树
3. 后序线索二叉树

### 树的遍历

- 先序遍历：先访问根节点，再依次访问根节点的每颗子树，以此类推。
- 后序遍历：线依次访问根节点的每颗子树，再访问根结点。

树的先序遍历相当于二叉树的先序遍历，后序遍历相当于二叉树的中序遍历。

### 森林遍历

- 先序遍历：先访问森林中第一棵树的根节点，然后先序遍历第一棵树中根节点的子树，最后先序遍历森林中除了第一棵树以外的其他树。
- 后序遍历：后序遍历先访问最后一棵树中根节点的子树，然后访问第一棵树的根节点，最后后序遍历森林中除了第一棵树以外的其特树。

先序遍历对应了二叉树的先序遍历，后序遍历对应了二叉树的中序遍历。

### 赫夫曼树和赫夫曼编码

赫夫曼树又被称为最优二叉树，特点是带权路径最短。

- 路径：从树中一个结点到另一个结点的分支所构成的路线。
- 路径长度：路径长度指的是路径上的分支数目。
- 树的路径长度：树的路径长度是指根到每个结点的路径长度之和。
- 带权路径长度：结点具有权值，从该结点到根之间的路径长度乘以结点的权值，就是该节点的带权路径长度。
- 树的带权路径长度(WPL)：树的带权路径长度是指树中所有叶子节点的带权路径长度之和。

### 赫夫曼树特点

1. 权值越大的结点，距离根结点越近
2. 树中没有度为1的结点，这类树又叫做正则(严格)二叉树
3. 树的带权路径长度最短。

## 图

图是由结点的有穷集合V和边的集合E组成，在图结构中，结点被称为顶点，边是顶点的有序偶对，如果两个顶点之间存在一条边，则表示这两个顶点具有相邻关系。

### 有向图和无向图

- 有向图：每条边都有方向，有向图中的边称为弧，含箭头的一端称为弧头，另一端称为弧尾。
- 无向图：每条边都没有方向

与顶点相关的边的边数称为顶点的度。

### 有向完全图和无向完全图

如果有向图中有n个顶点，则最多有n(n-1)条边，图中任意两个顶点都有两条边相连，将具有n(n-1)条边的有向图称为完全有向图，如果无向图中有n个顶点，则最多有n(n-1)/2条边，任意两个顶点之间有一条边，将具有n(n-1)/2条边的无向图称为无向完全图。

### 简单路径

序列中顶点不重复出现的路径称为简单路径

### 回路

若在一条路径中第一个顶点和最后一个顶点相同，则这条路径就是一条回路。

### 连通、连通图和连通分量

在无向图中，如果从顶点vi到顶点vj有路径，则成为连通，如果图中任意两个顶点之间都连通，则称图为连通图，否则，图中的极大连通子图就被称为连通分量。

### 强连通图和强连通分量

在有向图中，若从vi到vj有路径，则称vi到vj是连通的，如果对于每一对顶点vi和vj，从vi到vj和从vj到vi都有路径，就称为强连通图，否则，将其中的极大强连通子图称为强连通分量。

### 权和网

图中每条边都可以附有一个对应的数，这种与边的相关的数称为权，权可以表示从一个顶点到另一个顶点的距离或者花费的代价，边上带有权的图称为带权图，也成为网。

### 图的存储

1. 邻接矩阵：邻接矩阵是图的顺序存储结构，由邻接矩阵的行数或列数可以知道图中的顶点数，对于无向图，邻接矩阵是对称的。
2. 邻接表：是图的一种链式存储结构，所谓邻接表就是对图中每个顶点i建立一个单链表，每个单链表的第一个结点存放有关顶点的信息，把这一结点看错链表的表头，其余结点存放有关边的信息。
3. 邻接多重表：由定点表和边表组成，每一条边用一个结点表示，其顶点结点结构和边表结点结构。

### 图的遍历算法

- DFS 深度优先搜索算法，和栈有关系。
- BFS 广度优先搜索算法，和队列有关系。

### DFS深度优先搜索算法

首先访问出点v，并将其标记为已经访问过的，然后选取与v邻接的未被访问过的任意一个顶点w，并访问它，再选与w邻接的未被访问的任一顶点并访问，以此循环，当一个顶点所有的邻接顶点都被访问的过时，则依次退回到最近未被访问过的顶点，如果该顶点还有其他邻接顶点未被访问，则从这些未必访问的顶点中娶一个并重复以上过程。

### 深度搜索树

把图的深度优先搜索遍历过程中所经历的边保留，其余的边删除，就会形成一棵树，成为深度搜索树。

### BFS广度优先搜索遍历

BFS类似于树的层次遍历，基本思想是：首先访问起始顶点v，然后选取与v邻接的全部顶点w1...wn进行访问，再依次访问w1...wn的全部顶点，除了被访问过的，以此类推，直到所有顶点都被访问过为止。

广度优先搜索遍历图的时候，需要一个队列，算法步骤如下

1. 任取图中一个顶点访问，入队，并且将其顶点标记为访问过的。
2. 当队列不空的时候循环执行，出队，检查出队顶点的所有邻接顶点，访问没有被访问过的邻接顶点并将其入队。
3. 当队列为空的时候跳出循环，广度优先搜索遍历完成。

## 最小(代价)生成树

### 普里姆算法

普里姆算法是从图中任意娶一个顶点，把它当成一棵树，然后从和这棵树相接的边中选一条最短(权值最小)的边，并将这边所及其所连接的顶点也并入这棵树中，此时得到一个2个结点的树，然后从和这棵树相接的变种选一条最短的边，并将这条边所连接的顶点加入树中，得到一棵3个结点的树，以此类推，直到图中所有的顶点都被收入树中为止，此时生成的树是最小生成树。

普里姆算法的时间复杂度是O(N^2),因为普里姆算法的时间复杂度只和图中顶点有关系，和边数没关系，所以普里姆算法适用于稠密图。

### 克鲁斯卡尔算法

每次找出候选边中权值最小的边，就将该边并入生成树中，重复此过程直到所有边都被检查完为止，将图中边的权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为侯选边，既是否该边的并入会构成回路，则将该边并入当前生成树中，直到所有边都被检查完为止。

克鲁斯卡尔算法的时间复杂度主要是看sort()和单层循环上，循环是线性级别的，所以关键还是sort的，排序算法处理的数据是由边决定的，和顶点数无关，所以克鲁斯卡尔算法适合稀疏图。

普利姆算法和克鲁斯卡尔算法都是针对无向图的。

## 最短路径

### 迪杰斯特拉算法

假设有两个集合S和T，集合S存放图中已经找到的最短路径顶点，集合T存放图中剩余顶点，初始化的时候，集合S中只有源点v0, 然后不断从集合T中选取到顶点v0到集合T中顶点的最短路径长度值，不断重复这个过程，直到集合T的顶点全部并入到S中来。

### 弗洛伊德算法

求图中某一顶点到其余各顶点的最短路径，如果求图中任意一对顶点间的最短路径，则考虑弗洛伊德算法。

### 拓扑排序

### AOV网

### AOE网

## 排序

排序的稳定性是指当排序序列中有两个或两个以上相同的关键字的时候，排序前和排序后这些关键字的相对位置，如果没有改变说明是稳定排序，否则就是不稳定。

### 排序算法分类

- 插入类排序
  - 直接插入排序
  - 折半插入排序
  - 希尔排序
- 交换类排序
  - 冒泡排序
  - 快速排序
- 选择类排序
  - 选择排序
  - 堆排序
- 归并类排序
  - 归并排序
  - n路归并排序
- 基数类排序
  - 多关键字排序



## 重点复习内容

- 线性表
- 栈和队列
- 串 KMP
- 广义表
- 稀疏矩阵
- 树
  - 层序遍历
  - 赫夫曼树
  - 赫夫曼编码
- 图
  - 邻接矩阵
  - 邻接链表
  - DFS和BFS
  - 迪杰斯特拉
  - 弗洛伊德
