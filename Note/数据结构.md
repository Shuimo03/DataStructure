# 数据结构



## 关于手写代码

只需要写出函数/方法即可，不需要加入main函数，#define尽量不用，伪代码不关心实现的细节，一个算法要考虑时间复杂度和空间复杂度，大O表示最小的上界，下界是最大的下界。

## 复杂度分析

### 时间复杂度

算法中基本操作的执行次数作为算法时间复杂度的度量，时间复杂度不是执行完一段程序的总时间，而是其中基本操作的总次数，时间复杂度从快到慢比较关系如下。

1. O(1)
2. O(logn)
3. O(n)
4. O(nlogn)
5. O(n^2)
6. O(n^3)
7. O(n^k)
8. O(2^n)

### 空间复杂度

算法的空间复杂度是指算法在运行所需要的存储空间的度量，主要考虑算法在运行过程中临时占用的存储空间大小，量级和时间复杂度一样。

### 算法复杂度分析

## 数据结构基本概念

1. 数据：数据元素是客观事物的符号表示，所有能输入到计算机中并且背计算机程序处理的符号总称，例如整数、实数和字符串都是数据。
2. 数据元素：数据元素是数据的基本单位，在计算机程序中通常将其作为一个整体进行考虑和处理，有时，一个数据元素可以由若干个数据项组成。
3. 数据项：数据项是数据结构中讨论的最小单位，是数据记录中最基本的、不可分的数据单位。
4. 数据对象：数据对象是性质相同的数据元素的集合，是数据的一个子集。
5. 数据结构
   1. 逻辑结构
   2. 存储结构
      1. 顺序存储结构
      2. 链式存储结构
      3. 索引存储结构
      4. 散列存储结构
   3. 数据的运算 **补**
6. 数据结构的逻辑结构
   1. 线性结构：线性结构是一个数据元素的有序(次序)集合，线性结构是指数据之间存在着一对一的线性关系数据结构。
      1. 集合中存在唯一的一个"第一个元素"
      2. 集合中存在唯一的一个"最后一个元素"
      3. 除最后一个元素之外，其他数据元素均有唯一的后继
      4. 除第一个元素之外，其他数据元素均有唯一前驱
   2. 非线性结构：特点是一对多。
      1. 树形结构
      2. 图形结构
7. 数据的物理结构
   1. 顺序存储方法：逻辑上相邻节点存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现。
   2. 链式存储方法：不要求逻辑上相邻的节点在物理位置上也相邻，结点间的逻辑关系是由附加的指针字段表示的。
   3. 索引存储方法：索引存储方法在存储结点信息之外，还要建立附加的索引表来标识结点的地址，索引项的一般形式是<关键字,地址>，关键字标识唯一一个结点，地址作为指向结点的指针。
   4. 散列存储方法：根据结点的关键字通过散列函数之间计算出该结点的存储地址，这抓存储方法本质上是顺序存储方法的扩展。

**数据元素之间的关系在计算机中有两种不同**的表示方法：**顺序映像和非顺序映像**，对应的存储结构分别是顺序存储结构和链式存储结构。顺序存储结构是指借助数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系，非顺序映像是指借助指针表示数据元素之间的逻辑关系。

### ADT 数据抽象类型

一个抽象数据类型，可以看作一些数据对象，以及附加在这些对象上的操作集合，ADT重在对功能的描述而不关心具体实现，数据对象集、数据关系集和操作集，数据关系集是指数据对象的组织方式，比如线性表的一对一，树的一对多，以及图的多对多关系，设计ADT注意事项如下

- 注意ADT的结构格式，类似C语言结构体写法。
- ADT大括号内用数据对象集、数据关系和操作集分开。
- 如果有操作集，则写出。
- 不同的数据对象类型，自上而下依次列出。
- 相同类型的数据对象，用集合表示法写出。
- 不同的操作自上而下。

## 算法基本概念

### 算法特性

算法就是任何良定义的计算过程，该过程取某个值或值的集合作为输入，并且产生某个值或值的集合作为输出，也可以理解为由基本运算及规定的运算顺序所构成的完整解题步骤。

1. 有穷性：一个算法必须保证执行有限步骤。
2. 确定性：算法的每一步骤必须有确定的定义。
3. 输入：一个算法有0个或多个输入，以刻画运算对象的初始情况。所谓0个输入是指算法本身确定了初始条件。
4. 输出：一个算法至少一个输出或多个输出，以反映对输入数据加工后的结果，没有输出的算法毫无意义。
5. 可行性：算法中所有操作都必须可以通过已经实现的基本操作进行运算，并且在有限次内实现，而且人们用笔和纸做有限次运算后也可以完成。

### 算法设计目标

1. 正确性
2. 可读性
3. 健壮性
4. 算法效率

### 递归和循环

## 线性表

### 线性表定义

线性表是具有**相同数据元素**的一个**有限**序列，该序列中所含元素的个数称为线性表的长度，用n表示，n>=0，n可以等于0，表示为一个空表，线性表中的数据元素具有相同的特性，线性表可以是有序的，也可以是无序的。

线性表的逻辑性是只有一个表头元素，只有一个表尾元素，表头元素没有前驱，表尾元素没有后继，除了表头表尾元素之外，其他元素，只有一个直接前驱，也只有一个直接后继。

### 线性表存储结构

1. 顺序存储结构：顺序表
   1. 随机访问特性
   2. 占用连续存储空间
   3. 存储分配只能提前分配，分配好了以后不能改变。
   4. 顺序表做插入操作要移动多个元素，删除也是一样。
2. 链式存储结构：链表
   1. 每个元素不仅包括元素信息，还包括元素之间逻辑关系的信息，
   2. 不支持随机访问。
   3. 结点存储空间利用率比较低。
   4. 动态分配，比较灵活。
   5. 链表中进行插入无序移动元素。

### 顺序表

表中所有元素都按逻辑顺序，依次存储在指定的存储位置，在一块连续的存储位置中，数组就是一个顺序表。

### 链表

在链表存储中，每个结点不仅包括存储元素的信息，还包括元素之间的逻辑关系，如单链表中前驱结点包含后继结点的地址信息，这样就可以通过前驱结点中的地址信息找到后继结点的位置。

### 链表分类

链表中每个结点包含数据域和指针域，指针域指向前驱或后继结点。

1. 单链表：指针域指向后继结点。
   1. 带头结点的单链表：头节点head指向头节点，头节点的值域不包含任何信息，换句话来说就是头结点只有指针域，从头结点的后继节点开始存储数据信息，头节点head始终不等于NULL，head->next = NULL表示单链表为空。
   2. 不带头结点的单链表：头指针head只想开始结点，当head = NULL的时候，表示链表为空。
2. 双链表：双链表是在单链表节点上添加一个指针域，指向当前节点的前驱，这样做可以方便后继来找到前驱，实现输出从终端结点到开始结点的数据序列。
   1. 带头结点的双链表：带头结点的双链表，当head->next为NULL的时候链表为空。
   2. 不带头结点的双链表：不带头节点的双链表，当head作为NULL的时候链表为空。
3. 循环单链表：只需要将单链表的最后一个指针域(空指针)指向链表中的第一个结点即可，并不是指向头节点，循环单链表可以实现从任意一个结点出发访问链表中的任何结点，也就是可以访问前驱或后继，而单链表只能访问当前结点的后继。
   1. 带头循环单链表：如果单循环链表是带头结点的，则最后一个结点的指针域要指向头节点，当head等于head->next，链表为空。
   2. 循环不带头单链表：不带头循环单链表，则最后一个指针域要指向开始结点，当head等于NULL，链表为空。
4. 循环双链表：即将终端节点的next指针指向链表中的第一个结点，将链表中第一个结点指针prior指向终端结点，循环链表的构造源来自双链表。
   1. 循环带头双链表：带头结点的循环双链表中是没有空指针的，所以在空的情况下，head->next和head->prior都必然等于head，所以判断是否为空，只需要检查head->next和next->prior两个指针中任意一个是否等于head指针即可，判断代码如下，任选一种。
      1. head->next == head;
      2. head->prior = head;
      3. head->next == head && head->prior == head;
      4. head->next == head || head->prior == head;
   2. 循环不带头双链表：当head等于NULL的时候，不带头结点的循环链表为空。
      1. head == NULL
5. 静态链表：静态链表借助一维数组表示，静态链表来指一个结构体数组，数组中每一个结点含有两个分量，一个是元素分量data，一个是指针分量，指示当前节点的直接后继结点在数组中的位置。

### 顺序表操作

- 插入：时间复杂度O(n)
- 删除：时间复杂度O(n)
- 查找：时间复杂度O(1)

### 链表操作

- 插入：时间复杂度O(1)
- 删除：最好情况是O(1)，最坏情况是O(n)。
- 查找：最坏情况是O(n)

新元素插入表中，移动的个数为n-i，n为表的长度，i为表中下标。

## 栈和队列

### 栈

栈是一种只能在一端进行插入或删除只是的线性表，其中允许进行插入或删除的一段被称为栈顶，另一头称为栈底，栈底固定不变，栈的插入和删除一般称为入栈和出栈，栈的特性是先进后出FILO。

### 栈的存储结构

- 顺序表实现栈：顺序栈
- 链表实现栈：链表栈

### 栈的数学性质

当n个元素以某种顺序进栈的时候，并且可以在任何时刻出栈的时候，所获得元素排列数目N满足下面函数的计算。
$$
N = \frac{1}{n+1}C{n \choose 2n}
$$

### 顺序栈的状态

1. 栈空 st.top == -1 st表示为栈，top为栈顶，top顺序表中代表为所在数组的一个变量，在链表中为一个指针。
2. 沾满 st.top == maxsize; maxsize为栈的最大容量
3. 栈溢出
   1. 上溢：栈满了继续进行入栈操作就会发生上溢出。
   2. 下溢：栈空继续进行出栈操作就会发生下溢出。
4. 进栈操作：++(st.top); st.data[st.top] = x;
5. 出栈操作：x = st.data[top];--(st.top);

### 链栈的状态

1. 栈空：stack->next = NULL
2. 栈满：假设内存无限大，栈不可能满
3. 进栈操作：p = stack->next; x = p->data; stack->next  = p->next; free(p);

### 队列

队列是一种受限的线性表，限制在表的一端插入，一段删除，插入的称为队尾，删除的称为队头，插入新元素的操作称为入队，新元素入队以后称为新的队尾元素，从队列中删除的元素称为出队，队列的特性是先进先出FIFO，可以用顺序表和链表来实现。

### 队列的实现

- 顺序表实现队列：顺序队
- 链表实现队列：链队

### 循环队列

在顺序队中，通常让尾指针rear指向刚进队的元素位置，让队首指针front指向刚出队的元素位置，所以元素进队的时候，rear要像后移动，元素出队的时候，front也要向后移动，这样经过一系列的出队和入队操作，两个指针最终会到达数组的末端，虽然队中没有元素，但是仍然无法让元素进队，造成假溢出，解决这个问题，要把数组弄成一个环，让rear和front沿着环走。

### 循环队列操作

- 队空状态：qu.rear ==qu.front
- 队满状态：(qu.rear+1) % maxSize  = qu.front
- 元素x进队操作(移动队尾指针): qu.rear = (qu.rear+1)%maxSize; qu.data[qu.rear] =x;
- 元素x出队操作(移动队首指针): qu.front = (qi.front+1)%maxSize; x = qu.data[qu.front];

### 链队

- 队空状态 lqu->rear = NULL 或 lqu->front = NULL
- 队满状态 lqu->rear->next = p; lqu->rear = p;
- 元素进队操作 lqu->rear->next =p; lqu->rear = p;
- 元素出队操作 p = lqu->front; lqu->front = p->next; x = p->data; free(p);

### 共享栈

共享栈是为了提高内存的利用率和减少溢出的可能性而设计的，共享栈共用一块连续的内存空间，所以两个栈都是顺序栈，因为顺序表的特性是内存要提前分配好，并且这个连续的存储空间有恒定不变的两端，所以这两个栈的栈底分别位于存储空间的两端，确定栈顶必在存储空间内，所以当两栈相遇的时候，存储空间被利用尽，会发生上溢出。

### 双端队列

双端队列是一种插入和删除操作在两端都可以进行的线性表，可以把双端队列看成栈底连在一起的两个栈，和两个栈共享存储空间的共享栈不同之处在于，两个栈的栈顶指针是向两端延伸的，因为双端队列运行在两端插入和删除，所以需要两个指针end1和end2，分别指向双栈队列中的两端元素。

## 树与二叉树

### 树的定义

数是一种非线性的数据结构，是多个节点的集合，由唯一的根和若干棵互不交互的子树组成，其中每一棵子树都是一棵树，性质和之前一样。树的结点数目可以为0，为0的时候这棵树称为空树，属于特殊情况。

- **节点的度**：一个节点含有的子树的个数称为该节点的度；
- **结点**：
- **树的度**：一棵树中，最大的节点度称为树的度；
- **叶节点**或**终端节点**：度为零的节点；
- **非终端节点**或**分支节点**：度不为零的节点；
- **父亲节点**或**父节点**：若一个节点含有子节点，则这个节点称为其子节点的父节点；
- **孩子节点**或**子节点**：一个节点含有的子树的根节点称为该节点的子节点；
- **兄弟节点**：具有相同父节点的节点互称为兄弟节点；
- 节点的**层次**：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
- **深度**：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；
- **高度**：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；
- **堂兄弟节点**：父节点在同一层的节点互为堂兄弟；
- **节点的祖先**：从根到该节点所经分支上的所有节点；
- **子孙**：以某节点为根的子树中任一节点都称为该节点的子孙。
- **森林**：由m（m>=0）棵互不相交的树的集合称为森林；

### 树的存储结构

1. 顺序存储结构：使用一维数组实现，数组下标表示树的结点，数组中的元素内容表示该节点的双亲结点，结点下标和结点内容之间的关系，可以表示为一棵树。
2. 链式存储结构：
   1. 孩子存储结构
   2. 孩子兄弟存储结构

### 二叉树

在树的基础上再加两个限制条件就可以得到二叉树

1. 每个结点最多两棵子树，二叉树中结点只能是0,1,2
2. 子树有左右顺序之分，不能颠倒。
3. 二叉树5种基本形态
   1. 空二叉树
   2. 只有根节点
   3. 只有左子树，右子树为空。
   4. 只有右子树，左子树为空。
   5. 既有左子树，又有右子树。

### 满二叉树和完全二叉树

在一棵二叉树中，如果所有的分支节点都有左孩子和右孩子结点，并且叶子节点都集中在二叉树的最下一层，这样的二叉树称为满二叉树。

如果对一棵深度为k、有n个结点的二叉树进行编号以后，各结点的编号与深度为k的满二叉树中相同位置上结点的编号相同，则是完全二叉树。

### 完全二叉树性质

1. 完全二叉树叶子节点要么在最后一层，要么在倒数第二层。
2. 完全二叉树的倒数第二层及以上都是满二叉树。
3. 节点数为偶数则直接除以2即可，要是为奇数则节点数加1后除以2，得到叶子节点。

### 二叉树主要性质

1. 性质1：非空二叉树上叶子节点数等于双分支节点数加1。

2. 性质2：二叉树的第i层上最多有2^i-1(i>=1)个结点。

3. 性质3：高度或深度为k的二叉树最多有2^k-1(k>=1)个结点，换句话来说，满二叉树中前k层的结点个数为2^k-1

4. 性质4：有n个结点的完全二叉树，对各结点从上到下，从左到右依次编号，则结点之间的关系如下

   1. 如果i为某节点a的编号，则：
      1. 如果i不等于1，则a的双亲结点的编号为(i/2)
      2. 如果2i<=n，则a左孩子的编号为2i；如果2i>n，则a无左孩子。
      3. ​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +
      4. 如果2i+1<=n，则a右孩子的编号为2i+1；如果2i+1>n，则a无右孩子。

5. 性质5：给定n个结点，能构成h(n)种不同的二叉树。卡特兰数
   $$
   h(n) = \frac{{(2n)!}}{(n+1)!n!}
   $$
   
6. 性质6：具有n(n >=1)个结点的完全二叉树的高度或深度，为Log2n+1

### 二叉树存储结构

1. 顺序存储结构：顺序存储结构用一个数组来存储一颗二叉树，适合完全二叉树，存储一般类型的二叉树容易造成空间浪费。
2. 链式存储结构：不便于存储任意形态的二叉树，因为二叉树是一个根节点和两棵子树之间的关系，所以设计出一个数据域和两个指针域的链式结点结构。

### 二叉树遍历算法

1. 前序遍历
2. 中序遍历
3. 后序遍历
4. 层次遍历

### 先序遍历

前序遍历和中序遍历，中序遍历和后序遍历都可以唯一确定这颗二叉树，但是前后遍历不行，逆后序遍历序列只不过是对先序遍历过程中对左右子树遍历顺序交换所得到的结果。

如果二叉树为空，直接返回，什么都不做，不为空的话，就是根节点，左子树，右子树。

```c
void preorder(BTNode *p){
    if(p == NULL) return;
    printf("%d\n", &p->data); //输出根节点;
    preorder(p->lchild);
    preorder(p->rchild);
}
```

### 中序遍历

如果二叉树为空，直接返回，什么都不做，不为空的话，左子树，根节点，右子树。

```c
void inorder(BTNode *p){
    if(p == NULL) return;
    inorder(p->lchild);
    printf("%d\n", p->data);
    inorder(p->rchild);
}
```

### 后序遍历

如果二叉树为空，直接返回，什么都不做，不为空的话，左子树，右子树，根节点。

```c
void postorder(BTNode *p){
    if(p == NULL) return;
    postorder(p->lchild);
    postorder(p->rchild);
    printf("%d\n", p->data);
}

```

### 层序遍历

按照二叉树的层次顺序，对二叉树中各个结点访问，根据情况选择至左向右，自右向左，进行层次遍历，需要建立一个循环队列，先将二叉树头节点入队，然后出队，访问该节点，如果有它有左子树，则将右子树的根节点入队，如果它有右子树，则将左子树的根节点入队。然后出队列，对出队结点访问，反复如此，直到队列为空。

```c
void level(BTNode *p){
    int front, rear;
    BTNode *queue[maxSize]; //定义一个循环队列
    front = rear = 0;
    BTNode *q;
    if(p != NULL){
        rear = (rear + 1) % maxSize;
        queue[rear] = p; //根节点入队
        while(front != rear){ //当队列不为空的时候进行循环
            front = (front + 1) % maxSize;
            q = queue[front]; //队头结点出队
            printf("%d\n", q); //访问队头结点
            if(q->lchild != NULL){ //如果左子树不空，则左子树的根节点入队
                rear = (rear + !) % maxSize;
                queue[rear] = q->lchild;
            }
            if(q->rchild != NULL){ //如果右子树不空，则右子树的根节点入队
                rear = (rear + 1) % maxSize;
                queue[rear] = q->rchild;
            }
        }
    }
}
```

### 非递归遍历算法

```c
typedef struct BTNode{
    char data;
    BTNode *lchild;
    BTNode *rchild;
} BTNode;

void preoderNonrecursion(BTNode *bt){
    
    if(bt != NULL){

        BTNode *Stack[maxSize];//定义一个栈
        int top = -1; //初始化栈
        BTNode *p;
        Stack[++top] = bt;//根节点入栈
        while(top != -1){ //栈空循环退出,遍历结束
            p = Stack[top--];
            printf("%d\n", p->data);
            if(p->rchild != NULL)
                Stack[++top] = p->rchild;
            if(p->lchild != NULL)
                Stack[++top] = p->lchild;
        }
    }
}

void inorderNonrecursion(BTNode *bt){
    if(bt != NULL){
        BTNode *Stack[maxSize];
        int top = -1;
        BTNode *p;
        p = bt;
        while(top != -1 || p != NULL){ //左孩子存在,则右孩子入栈
            while(p!=NULL){
                Stack[++top] = p;
                p = p->lchild;
            }
            if(top != -1){ //在栈不空的情况下出栈并输出栈结点
                p = Stack[top--];
                printf("%d\n", p->data);
                p = p->rchild;
            }
        }
    }
}

void postorderNonrecursion(BTNode *bt){
    if(bt != NULL){
        /*定义两个栈*/
        BTNode *Stack1[maxSize];
        int top1 = -1;
        BTNode *Stack2[maxSize];
        int top2 = -1;
        BTNode *p = NULL;
        Stack1[++top1] = bt;
        while(top1 != -1){
            p = Stack1[top1--];
            Stack2[++top2] = p;
            if(p->lchild != NULL){
                Stack1[++top1] = p->lchild;
            }
            if(p->rchild != NULL){
                Stack1[++top1] = p->rchild;
            }
        }
        while(top2 != -1){
            p = Stack2[top2--];
            printf("%d\n", p->data);
        }
    }
}
```

### 线索二叉树

一个二叉树通过如下方式串联起来，所有原本为空的右孩子指针改为指向该节点在中序序列中的后继，所有原本为空的左孩子指针改为指向该节点的中序序列的前驱，在二叉树线索化的过程中会把树中的空指针利用起来作为寻找当前结点前驱或后继的线索，这样就出现了一个问题，即线索和树中原来指向孩子结点的指针无法区分，为此设计两类指针ltag和rtag，两者为标识域，n个结点的二叉树含有n+1个空指针域，

- ltag = 0，则表示lchild为指针，指向结点的左孩子，如果ltag = 1，则表示lchild为线索，指向结点的直接前驱。
- rtag = 0，则表示rchild为指针，指向结点的右孩子，如果rtag = 1，则表示rchild为线索，指向结点的直接后继。

对一个二叉树中所有节点的空指针域按照某种遍历方法加线索的过程叫做线索化，被线索化的二叉树被称为线索二叉树。

### 线索二叉树分类

1. 前序线索二叉树
2. 中序线索二叉树
3. 后序线索二叉树

### 树的遍历

- 先序遍历：先访问根节点，再依次访问根节点的每颗子树，以此类推。
- 后序遍历：线依次访问根节点的每颗子树，再访问根结点。

树的先序遍历相当于二叉树的先序遍历，后序遍历相当于二叉树的中序遍历。

### 森林遍历

- 先序遍历：先访问森林中第一棵树的根节点，然后先序遍历第一棵树中根节点的子树，最后先序遍历森林中除了第一棵树以外的其他树。
- 后序遍历：后序遍历先访问最后一棵树中根节点的子树，然后访问第一棵树的根节点，最后后序遍历森林中除了第一棵树以外的其特树。

先序遍历对应了二叉树的先序遍历，后序遍历对应了二叉树的中序遍历。

### 森林转换树



### 树转换森林

### 赫夫曼编码

赫夫曼编码通过每个字符的出现频率。来构造出字符的最有二进制，每个字符使用唯一二进制串表示，称为码字，如果使用定长编码就需要使用3位来表示6个字符，变长编码的压缩率要比定长编码效率高，变长编码是给予高频字符断码字，给予低频字符常码字，前缀码是没有任何码字是其他码字的前缀，前缀码可以保证达到最优数据压缩率，前缀码作用就是简化解码过程，

### 赫夫曼树

赫夫曼树又被称为最优二叉树，特点是带权路径最短。

- 路径：从树中一个结点到另一个结点的分支所构成的路线。
- 路径长度：路径长度指的是路径上的分支数目。
- 树的路径长度：树的路径长度是指根到每个结点的路径长度之和。
- 带权路径长度：结点具有权值，从该结点到根之间的路径长度乘以结点的权值，就是该节点的带权路径长度。
- 树的带权路径长度(WPL)：树的带权路径长度是指树中所有叶子节点的带权路径长度之和。

### 赫夫曼树特点

1. 权值越大的结点，距离根结点越近
2. 树中没有度为1的结点，这类树又叫做正则(严格)二叉树
3. 树的带权路径长度最短。

## 图

### 图的基本概念

路径和路径长度

简单路径：序列中顶点不重复出现的路径称为简单路径

回路：若一条路径中第一个结点和最后一个结点相同，则这条路径就是一条回路。

度：

入度：该结点被其他结点指向的边数就是入度。

出度：该结点指向其他结点的边数就是出度。

图是由结点的有穷集合V和边的集合E组成，在图结构中，结点被称为顶点，边是顶点的有序偶对，如果两个顶点之间存在一条边，则表示这两个顶点具有相邻关系。

### 有向图和无向图

- 有向图：每条边都有方向，有向图中的边称为弧，含箭头的一端称为弧头，另一端称为弧尾。
- 无向图：每条边都没有方向

与顶点相关的边的边数称为顶点的度。

### 有向完全图和无向完全图

如果有向图中有n个顶点，则最多有n(n-1)条边，图中任意两个顶点都有两条边相连，将具有n(n-1)条边的有向图称为完全有向图，如果无向图中有n个顶点，则最多有n(n-1)/2条边，任意两个顶点之间有一条边，将具有n(n-1)/2条边的无向图称为无向完全图。

通过深度遍历和拓扑排序可以判断有向图是否有回路。

### 简单路径

序列中顶点不重复出现的路径称为简单路径

### 回路

若在一条路径中第一个顶点和最后一个顶点相同，则这条路径就是一条回路。

### 连通、连通图和连通分量

在无向图中，如果从顶点vi到顶点vj有路径，则成为连通，如果图中任意两个顶点之间都连通，则称图为连通图，否则，图中的极大连通子图就被称为连通分量。

### 强连通图和强连通分量

在有向图中，若从vi到vj有路径，则称vi到vj是连通的，如果对于每一对顶点vi和vj，从vi到vj和从vj到vi都有路径，就称为强连通图，否则，将其中的极大强连通子图称为强连通分量。

### 权和网

图中每条边都可以附有一个对应的数，这种与边的相关的数称为权，权可以表示从一个顶点到另一个顶点的距离或者花费的代价，边上带有权的图称为带权图，也成为网。

### 图的存储

1. 邻接矩阵：邻接矩阵是图的顺序存储结构，由邻接矩阵的行数或列数可以知道图中的顶点数，对于无向图，邻接矩阵是对称的，矩阵中第i行的元素之和即为顶点i的出度，第j列的元素之和为顶点j的入度。
2. 邻接表：是图的一种链式存储结构，所谓邻接表就是对图中每个顶点i建立一个单链表，每个单链表的第一个结点存放有关顶点的信息，把这一结点看错链表的表头，其余结点存放有关边的信息。
3. 邻接多重表：由定点表和边表组成，每一条边用一个结点表示，其顶点结点结构和边表结点结构。

### 图的遍历算法

- DFS 深度优先搜索算法，和栈有关系。
- BFS 广度优先搜索算法，和队列有关系。

### DFS深度优先搜索算法

首先访问出点v，并将其标记为已经访问过的，然后选取与v邻接的未被访问过的任意一个顶点w，并访问它，再选与w邻接的未被访问的任一顶点并访问，以此循环，当一个顶点所有的邻接顶点都被访问的过时，则依次退回到最近未被访问过的顶点，如果该顶点还有其他邻接顶点未被访问，则从这些未必访问的顶点中娶一个并重复以上过程，**DFS算法类似于树的前序遍历**

### 深度搜索树

把图的深度优先搜索遍历过程中所经历的边保留，其余的边删除，就会形成一棵树，成为深度搜索树。

### BFS广度优先搜索遍历

BFS类似于树的层次遍历，基本思想是：首先访问起始顶点v，然后选取与v邻接的全部顶点w1...wn进行访问，再依次访问w1...wn的全部顶点，除了被访问过的，以此类推，直到所有顶点都被访问过为止，**BFS算法类似于层次遍历**

广度优先搜索遍历图的时候，需要一个队列，算法步骤如下

1. 任取图中一个顶点访问，入队，并且将其顶点标记为访问过的。
2. 当队列不空的时候循环执行，出队，检查出队顶点的所有邻接顶点，访问没有被访问过的邻接顶点并将其入队。
3. 当队列为空的时候跳出循环，广度优先搜索遍历完成。

## 最小(代价)生成树

### 最小生成树特点

1. 最小生成树在每条边权值相等的时候，生成树不唯一。
2. 最小生成树唯一的时候，是每条边权值不相同的时候。
3. 如果图的边的权值都为正数，那么最小生成树就是该图的所有包含所有[顶点](https://zh.wikipedia.org/wiki/顶点_(图论))的子图中权值最低的子图。

### prim普里姆算法

普里姆算法是从图中任意娶一个顶点，把它当成一棵树，然后从和这棵树相接的边中选一条最短(权值最小)的边，并将这边所及其所连接的顶点也并入这棵树中，此时得到一个2个结点的树，然后从和这棵树相接的变种选一条最短的边，并将这条边所连接的顶点加入树中，得到一棵3个结点的树，以此类推，直到图中所有的顶点都被收入树中为止，此时生成的树是最小生成树。

**普里姆算法的时间复杂度是O(N^2),因为普里姆算法的时间复杂度只和图中顶点有关系，和边数没关系，所以普里姆算法适用于稠密图。**

### Kruskal克鲁斯卡尔算法

每次找出候选边中权值最小的边，就将该边并入生成树中，重复此过程直到所有边都被检查完为止，将图中边的权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为侯选边，既是否该边的并入会构成回路，则将该边并入当前生成树中，直到所有边都被检查完为止。

**克鲁斯卡尔算法的时间复杂度主要是看sort()和单层循环上，循环是线性级别的，所以关键还是sort的，排序算法处理的数据是由边决定的，和顶点数无关，所以克鲁斯卡尔算法适合稀疏图。**

**普利姆算法和克鲁斯卡尔算法都是针对无向图的。**

## 最短路径

### 迪杰斯特拉算法

假设有两个集合S和T，集合S存放图中已经找到的最短路径顶点，集合T存放图中剩余顶点，初始化的时候，集合S中只有源点v0, 然后不断从集合T中选取到顶点v0到集合T中顶点的最短路径长度值，不断重复这个过程，直到集合T的顶点全部并入到S中来。

### Flo弗洛伊德算法

求图中某一顶点到其余各顶点的最短路径，如果求图中任意一对顶点间的最短路径，则考虑弗洛伊德算法，时间复杂度是O(N^3)，空间复杂度是O(N^2)

### 拓扑排序

拓扑排序时间复杂度是O(n+e)

### AOV网

AOV不带权值，顶点表示活动，边代表活动之间的先后关系，

### AOE网

AOE网带权值，边表示活动，边代表活动持续时间，顶点表示事件，事件是图中新活动开始或旧活动结束的标志，在AOE网中，从源点到回电的所有路径中，**具有最大路径长度**的路径被称为关键路径，完成整个工期的最短时间就是关键路径长度所代表的时间，关键路径上的活动称为关键活动，关键路径既代表了一个最短又代表了一个最长，在图中代表最长路径，在工期中代表最短完成时间。

## 图的题型

1. 基本概念
2. 根据顶点算最少边数/最多边数
3. 拓扑排序
4. 图的存储
5. 深度优先搜索和广度优先搜索
   1. 搜索结果
   2. 遍历序列个数
6. 最小生成树
7. AOE网
8. 最短路径算法
9. 前中后序遍历图

## 集合和查找

### 查找的基本概念

查找的定义：给定一个值k，在含有n个记录的表中查找出关键字等于k的记录，如果找到了，则查找成功，返回该记录的信息或该记录在表中的位置，否则查找失败，则给出查找失败的信息，举个例子，数组arr[]={1,2,3,4,5} k = 5，要不返回数组里和k相等数，要不返回和k相等数组下标，如果没有，则可以printf("未找到")或者其他失败信息。

由此可知，得到两个重要信息记录和关键字。

### 查找的数据结构方式

1. 使用那种数据结构来表示查找表，即查找表中的记录是按照何种方式组织的。
2. 查找表中关键字的次序，即对无序集合查找还是有序集合查找。

因为查找算法的基本操作是和关键字的比较，所以关键字比较次数和待查找关键字有关，所以通常把查找过程中对关键字的平均比较次数，也被称为平均查找长度，作为衡量一个查找算法的效率高低表中，平均查找长度用ASL来表示，其定义如下
$$
ASL = \sum_i^n p_i\times c_i (i =1)
$$
n是查找表中记录的个数，pi是查找第i个记录的概率，ci是找到第i个记录所需要进行比较的次数，即查找长度。

### 顺序查找(时间复杂度O(N))

从表的一端开始，顺序扫描线性表，依次将扫描到的关键字和给定值k做对比，如果当前扫描的关键字与k相等，就表示查找成功，如果扫描结束，还没发现，就说明查找失败，由此可知，顺序查找法适合顺序表和链表，对于顺序表是数组下标递增来顺序扫描数组中的各个元素，对于链表是通过表结点指针p，反复执行p=p->next来扫描表中各个元素。

```c
int search(int arr[],int n, int k){
	int flag = 0;
	for(int i = 0; i < n; i++){
		if(arr[i] == k){
			flag = 1; //如果查找成功就把flag变成1 
		}
	}
	return flag; //查找失败返回0 
}

```

### 折半查找(O(logn))

折半查找要求线性表是有序的，即表中记录按关键字有序，假设是递增有序的，折半查找的思路是，设一个查找区间R[low...high]，首先确定该区间中的中间位置，mid  = (low+high)/2，然后将带查找的k值和R[mid]作比较，如果相同就查找成功，如果R[mid]>k，说明从R[mid]到R[high]位置都比k大，所以去找R[low]到R[mid]位置，以此类推，递归处理新区间，直到子区间的长度小于1的时候查找过程结束，具体算法实现如下

```c
int search(int arr[], int l,int r, int k){
	l = arr[0];
	int len = sizeof(arr)/sizeof(arr[0]);
	r = arr[len];
	while(l < r){
		int mid = (l+r)/2;
		if(arr[mid] == k){
			return mid;
		}
		else if(arr[mid] > k){
			return search(arr,l,mid-1,k);
		}
		else{
			return search(arr,mid+1,r,k);
		}
	}
	return -1;
}
```

折半查找的过程可以用二叉树来表示，把当前查找区间中的中间位置作为树根，左子表作为左子树，右子表作为右子树，得到的二叉树就被称为折半查找判定树。

但是二分查找的最坏情况是O(n)，因为会退化成线性表，也就输说，二叉判断树只有左子树或者右子树，所以查找算法是O(n)。

### 分块查找

分块查找又被称为索引顺序查找，其数据结构可以简单地描述为：分块查找把线性表分成若干块，每一块中的元素存储顺序是任意的，**但是块和块之前必须按照关键字大小有序排列**，即前一块追踪最大的关键字要小于后一块的最小关键字，对顺序表进行分块查找需要额外建立一个索引表，表中的每一项对应线性表中的一块，每个索引项都由键值分量和链值分量组成，键值分量存放对应块的最大关键字，链值分量存放指向本块的第一个元素指针和最后一个元素指针(**这里的指针可以是数组下标或地址，或者是任何可以帮助找到这个元素的信息**)，显然索引表中的所有索引都是按照其关键字递增顺序排列的。

定义索引表

```c
#include<stdio.h> 
#define maxSize 500
typedef struct{
	int key; //假设表中元素都为int
	int low,high; //假设表中的第一个元素和最后一个元素位置 
}indexElem;

indexElem index[maxSize]; //定义索引表
 
```

分块查找算法分为两个部分进行，首先确定带查找元素属于那一块，然后在块内精确查找，因为索引表是有序递增的，所以可以用二分查找，块内元素较少，就可以使用顺序查找。可以得出整个算法的平均查找长度是两次查找的平均长度之和，即二分查找平均长度+顺序查找平均查找长度。

### 二叉排序树(BST)和平衡二叉树

#### 二叉排序树定义

二叉排序树或者是空树，或者满足以下性质的二叉树

1. 如果它的左子树不空，则左子树上所有关键字的值都小于根关键字的值。
2. 如果它的右子树不空，则右子树上所有关键字的值都大于根关键字的值。
3. 左右子树又各是一颗二叉排序树。

由二叉排序树的定义可以知道，如果输出二叉排序树的中序遍历序列，则这个序列是递增有序的。

#### 二叉排序树存储

二叉排序树通常使用二叉链表进行存储，其结点类型定义和一般二叉树类似。

```c
typedef struct{
	
	int key;
	struct BTNode *lchild;
	struct BTNode *rchild;
}BTNode;
```

#### 二叉排序树基本算法

1. 查找关键字算法 平均情况是O(logn) 最坏情况是O(n)
2. 插入关键字算法 平均情况是O(logn) 最坏情况是O(n)
3. 删除关键字算法 平均情况是O(logn) 最坏情况是O(n)
4. 构造排序二叉树算法 平均情况是O(n) 最坏情况是O(n)

查找算法的前提是同时有左右子树的情况下，查找的关键字要么在左子树，要么在右子树，比根节点值大的，在右子树，比根节点值小的，在左子树，如果只有单一子树的情况下，时间复杂度就会来到O(n)。

```c
BTNnode* BSTSearch(BTNode* bt, int key) {
	if(bt == null){
		return NULL;
	}
	else{
		if(bt->key == key){ //正好等于根节点的关键字，则返回所在的指针位置 
			return bt;
		}
		else if(key bt->key){ //小于根节点，就在左子树上寻找 
			return BSTSearch(bt->lchild,key);
		}
		else{ //反之亦然 
			return BSTSearch(bt->rchild,key);
		}
	}
}
```

二叉排序树是一个查找表，插入一个关键字首先要找到插入位置，对一个不存在于二叉排序树中的关键字，其查找不成功的位置就是该插入的位置。

```c
int BSTInsert(BTNode *&bt, int key){ //因为bt要改变，所以使用引用类型指针 
	if(bt == NULL){ //当前位置为空，可以插入 
		bt =(BTNode*)malloc(sizeof(BTNode)); //创造新节点 
		bt->lchild = bt->rchild = NULL;
		bt->key = key;
		return 1;
	}
	else if(key == bt->key){ //插入结点相同 
		return 0;
	}
	else if(key < bt->key){
		return BSTInsert(bt->lchild,key);
	}
	else{
		return BSTInsert(bt->rchild,key);
	}
}
```

在二叉排序树中插入的关键字均存储在新创建的叶子上，由于找到的插入位置总是在空指针域上，所以在空指针域上连接一个新结点必为叶子结点。

```c
void CreateBST(BTNode *&bt,int key[], int n){
	bt = NULL;
	for(int i = 0; i < n; i++){
		BSTInsert(bt,key[i]);
	}
}
```

当二叉排序树中删除一个关键字的时候，不能把这个关键字的子树也删除，而是删除这一个结点，并且保证二叉排序树的特性。

### 平衡二叉树

平衡二叉树又被称为AVL树，是一种特殊的二叉树，其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1，换句话来说，以树中所有节点为根的树左右子树高度之差的绝对值不超过1。平衡二叉树算是一种二叉排序树。树越矮查找效率越高，为了判断一颗二叉树是否为平衡二叉树，所以引进了平衡因子，平衡因子是针对树中的结点来说的，一个结点的平衡因子为其左子树的高度减去右子树高度，对于平衡二叉树来说，树中所有结点的平衡因子取值都是-1/0/1三个值。

#### 平衡二叉树建立

建立平衡二叉树过程和建立二叉排序树过程基本一样，都是将关键字逐步插入空树的过程，不同的是，在建立平衡二叉树的过程中，每插入一个新关键字都要进行检查，看看受否新关键字的插入，是否会影响到原二叉平衡树的平衡，即树中出现的平衡因子绝对值要大于1的结点，如果失去平衡则需要进行平衡调整。

#### 平衡调整

假设向平衡二叉树中插入一个新结点之后，破坏了平衡二叉树的平衡性，则首先要找出插入新结点后失去平衡的最小子树，然后在调整这个子树，变成平衡子树，当失去平衡的最小子树被调整称为平衡子树后，无序调整原有其他所有的不平衡子树，整个二叉排序树就会变成一颗平衡二叉树，所谓失去平衡的最小子树是以距离插入结点最近，并且以平衡因子绝对值大于1的结点作为根的子树，又称为最小不平衡子树。

平衡调整必须保持排序二叉树左小右大的性质，平衡调整有4种情况

1. LL型：右单旋转调整
2. RR型：左单旋转调整
3. LR型：先左后右双旋转调整
4. RL型：先右后左双旋转调整

### B-Tree树

B-树中所有结点孩子结点个数的最大值称为B-树的阶，通常用m表示，从查找效率考虑，要求m>=3，一棵m阶的B-树，或者是一颗空树，或者是满足以下要求的m叉树，拥有n个结点的B树高度是O(logn)

1. 每个结点最多有m个分支(子树)，而最少分支树要看是否为根节点，如果是根节点且不是叶子结点，则至少有两个分支，非根非叶节点至少有(m/2)个分支。
2. 有n(k<=n<=m)个分支的结点有n-1个关键字，它们按照递增顺序排列，k=2(根结点)或(m/2)非根节点。
3. 结点内关键字互不相等且按从小到大排列。
4. 叶节点处于同一层，可以用空指针表示，是查找失败到达的位置。
5. 所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。

平衡m叉树是指每个关键字的左侧子树和右侧子树高度差绝对值不超过1的查找树，其结点结构与上面提到的B-树结点结构相同，由此可见，B-树是平衡m叉查找树，但是限制更强，要求所有叶节点在同一层。

### B-Tree树操作

| 算法 | **平均**   | **最差**   |
| ---- | ---------- | ---------- |
| 空间 | O(*n*)     | O(*n*)     |
| 搜索 | O(log *n*) | O(log *n*) |
| 插入 | O(log *n*) | O(log *n*) |
| 删除 | O(log *n*) | O(log *n*) |

### B树关键字查找

B树关键字查找是二叉排序树的扩展，二叉排序树是二路查找，B树是多路查找，因为B树结点内的关键字是有序的，在节点内进行查找的时候除了顺序查找之外，还可以用折半查找来提高效率，从根节点开始，从上到下递归的遍历树。在每一层上，搜索的范围被减小到包含了搜索值的子树中。子树值的范围被它的父节点的键确定。

### B树插入

所有插入都从根节点开始，要插入一个新元素，首先搜索这棵树找到新元素应该被添加到的对应节点，将新元素插入到这一节点的步骤如下

1. 如果节点拥有的元素数量小于最大值，那么有空间容纳新的元素。将新元素插入到这一节点，且保持节点中元素有序。
2. 否则的话这一节点已经满了，将它平均地分裂成两个节点：
   1. 从该节点的原有元素和新的元素中选择出中位数
   2. 小于这一中位数的元素放入左边节点，大于这一中位数的元素放入右边节点，中位数作为分隔值。
   3. 分隔值被插入到父节点中，这可能会造成父节点分裂，分裂父节点时可能又会使它的父节点分裂，以此类推。如果没有父节点（这一节点是根节点），就创建一个新的根节点（增加了树的高度）。

如果分裂一直上升到根节点，那么一个新的根节点会被创建，它有一个分隔值和两个子节点。这就是根节点并不像内部节点一样有最少子节点数量限制的原因。每个节点中元素的最大数量是 *U*-1。当一个节点分裂时，一个元素被移动到它的父节点，但是一个新的元素增加了进来。所以最大的元素数量 *U*-1 必须能够被分成两个合法的节点。如果 *U*-1 是奇数，那么 *U*=2*L* ，总共有 2*L*-1 个元素，一个新的节点有 *L*-1 个元素，另外一个有 *L* 个元素，都是合法的节点。如果 *U*-1 是偶数，那么 *U*=2*L*-1,总共有 2*L*-2 个元素。 一半是 *L*-1，正好是节点允许的最小元素数量。

### B树删除

两种常用阐述策略

1. 定位并删除元素，然后调整树使它满足约束条件。
2. 从上到下处理这棵树，在进入一个结点之前，调整树使得之后一旦遇到了要删除的键，可以被直接删除而不用调整。

删除一个元素时有以下两种特殊情况

1. 这个元素用于分隔一个内部节点的子节点
2. 删除元素会导致它所在的节点的元素或子节点数量小于最低值

下面分别是这些情况的处理过程

#### 删除叶子节点中的元素

1. 搜索要删除的元素
2. 如果它在叶子节点，将它从中删除
3. 如果发生了下溢出，按照后面 “删除后重新平衡”部分的描述重新调整树

#### 删除内部节点中的元素

内部节点中的每一个元素都作为分隔两颗子树的分隔值，因此我们需要重新划分。值得注意的是左子树中最大的元素仍然小于分隔值。同样的，右子树中最小的元素仍然大于分隔值。这两个元素都在叶子节点中，并且任何一个都可以作为两颗子树的新分隔值。算法的描述如下：

1. 选择一个新的分隔符（左子树中最大的元素或右子树中最小的元素），将它从叶子节点中移除，替换掉被删除的元素作为新的分隔值。
2. 前一步删除了一个叶子节点中的元素。如果这个叶子节点拥有的元素数量小于最低要求，那么从这一叶子节点开始重新进行平衡。

#### 删除后的重新平衡

重新平衡从叶子节点开始向根节点进行，直到树重新平衡。如果删除节点中的一个元素使该节点的元素数量低于最小值，那么一些元素必须被重新分配。通常，移动一个元素数量大于最小值的兄弟节点中的元素。如果兄弟节点都没有多余的元素，那么缺少元素的节点就必须要和他的兄弟节点 **合并**。合并可能导致父节点失去了分隔值，所以父节点可能缺少元素并需要重新平衡。合并和重新平衡可能一直进行到根节点，根节点变成惟一缺少元素的节点。重新平衡树的算法如下：

- 如果缺少元素节点的右兄弟存在且拥有多余的元素，那么向左旋转
  1. 将父节点的分隔值复制到缺少元素节点的最后（分隔值被移下来；缺少元素的节点现在有最小数量的元素）
  2. 将父节点的分隔值替换为右兄弟的第一个元素（右兄弟失去了一个节点但仍然拥有最小数量的元素）
  3. 树又重新平衡
- 否则，如果缺少元素节点的左兄弟存在且拥有多余的元素，那么向右旋转
  1. 将父节点的分隔值复制到缺少元素节点的第一个节点（分隔值被移下来；缺少元素的节点现在有最小数量的元素）
  2. 将父节点的分隔值替换为左兄弟的最后一个元素（左兄弟失去了一个节点但仍然拥有最小数量的元素）
  3. 树又重新平衡
- 否则，如果它的两个直接兄弟节点都只有最小数量的元素，那么将它与一个直接兄弟节点以及父节点中它们的分隔值合并
  1. 将分隔值复制到左边的节点（左边的节点可以是缺少元素的节点或者拥有最小数量元素的兄弟节点）
  2. 将右边节点中所有的元素移动到左边节点（左边节点现在拥有最大数量的元素，右边节点为空）
  3. 将父节点中的分隔值和空的右子树移除（父节点失去了一个元素）
     - 如果父节点是根节点并且没有元素了，那么释放它并且让合并之后的节点成为新的根节点（树的深度减小）
     - 否则，如果父节点的元素数量小于最小值，重新平衡父节点

### 散列表(哈希表)

是根据键(Key)而直接访问在内存储存位置的[数据结构](https://zh.wikipedia.org/wiki/数据结构)。也就是说，它通过计算一个关于键值的函数，将所需查询的数据[映射](https://zh.wikipedia.org/wiki/映射)到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做[散列函数](https://zh.wikipedia.org/wiki/散列函数)，存放记录的数组称做**散列表**。，根据给定的关键字来计算出关键字在表中的地址，也是hash表和其他查找表的不同之处，在其他查找表中，关键字的地址跟关键字之间不存在确定的关系，而在hash表中，关键字和关键字地址有确定关系的，这种关系可以用hash函数H来表示，关键字为key，则H(key)称为hash地址，就是key在查找表中的地址。

### 常用散列表函数构造方法

1. 直接定址法：取关键字或关键字的某个线性函数为hash地址，即H(key) = key 或者 H(key) = a * key+b，其中ab为常数。

2. 数字分析法：假设关键字是r进制数，并且hash表中可能出现的关键字都是事先知道的，则可选取关键字的若干数位组成hash地址，选择的原则是使得到的hash地址尽量减少冲突，即所选位数上的数字尽可能是随机的。

3. 平方取中法：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。

4. 除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址，即

   
   $$
   H(key) = key\ mod\ p (p<=m)
   $$
   

一般p选择小于或等于表长的最大素数，这样可以减少冲突。

### 常用解决hash冲突处理方法

1. 开放定址法：以发生冲突的Hash地址为自变量，通过某种冲突解决函数得到一个新的空闲Hash地址方法。

   1. 线性探查法：从发生冲突的地址(设为d)开始，依次探查d的下一个地址，(当到达下标为m-1的hash表表尾的时候，下一个探查地址就是表首地址0)，直到吵到一个空位置为止，当m>=n(n是表中关键字的个数)的时候，一定要找到一个空位置，公式如下，该方法的缺点在于容易产生堆积问题。
      $$
      H_i(k) \ = (H(k)+i) \ Mod \ m \ (1<=i<=m-1)
      $$
      

   2. 平方探查法：假设发生冲突地址为d.则用平方探查法所得到的新的地址序列如下，很好的处理冲突的方法，可以减少出现堆积问题，缺点是不能探查到hash表上所有单元，但是至少可以探查一半。
      $$
      d+1^2,d-1^2,d+2^2,d-2^2,.....
      $$
      

2. 链地址法：是把所有的同义词用单链表连接起来，在这种方法中，hash表每个单元中存放的不再是记录本身，而是相应同义词单链表的表头指针。

## 排序

排序是指将原本无序的序列重新排列成有序或者有序过程，这个序列的每一项可能是单独的数据元素，也有可能是一条记录，如果是记录，则既可以按照记录的主关键字排序，也可以按照记录的次关键字排序，排序的稳定性是指当排序序列中有两个或两个以上相同的关键字的时候，排序前和排序后这些关键字的相对位置，如果没有改变说明是稳定排序，否则就是不稳定。

### 排序算法分类

- 插入类排序
  - 直接插入排序
  - 折半插入排序
  - 希尔排序
- 交换类排序
  - 冒泡排序
  - 快速排序
- 选择类排序
  - 选择排序
  - 堆排序
- 归并类排序
  - 归并排序
  - n路归并排序
- 基数类排序
  - 多关键字排序

基数排序是最特别的一类排序，因为基类排序是基于多关键字的排序，拿扑克牌打比方，可以先按照花色排序，分为4类，再按照A到K的顺序，排序使这副牌最终有序。

### 插入排序

1. 插入排序属于稳定排序
2. 插入排序的平均复杂度是O(n^2)最坏时间复杂度是O(n^2)最好时间复杂度是O(n)空间复杂度是O(1)

插入排序算法的算法思想是：每趟将一个待排序的关键字按照其值的大小插入到排好的部分有序序列的适当位置上，直到所有待排序关键字都被插入到有序序列中为止。

```c
void InsertSort(int arr[],int n){
    int i,j,temp;
    for(i = 0; i < n; i++){
         temp = arr[i];
         j = i-1;
        while(j >= 0 &&  temp < arr[j]){
            arr[j+1] = arr[j];
            --j;
        }
        arr[j+1] = temp;
    }
}
```

### 折半插入排序算法

1. 折半插入排序最好时间复杂度是O(nlogn)最坏情况是O(n^2)平均情况是O(n^2)
2. 空间复杂度是O(1)

折半插入排序的基本思想和直接插入排序类似，区别是查找插入位置的方法不同，折半插入排序是采用折半查找法来查找插入位置的，折半查找法的一个基本条件是序列已经有序，折半插入排序适合关键字较多的场景，和直接插入排序相比，折半插入排序在查找插入位置上面所化时间大大减少，折半插入排序在关键字移动次数方面和直接插入排序是一样的，所以其时间复杂度和直接插入排序还是一样的，折半插入排序的关键字比较次数和初始序列无关，因为每趟折半查找插入位置的适合，折半次数是一定的，折半一次就要比较一次，所以比较次数是一定的。

### 希尔排序

希尔排序又叫缩小增量排序，本质还是插入排序，只不过是将待排序列按某种规则分成几个子序列，分别对这几个子序列进行直接插入排序，这个规则的体现就是增量的选取，如果增量为1，就是直接插入排序。

#### 算法描述

1. 最坏时间复杂度是O(nlogn)最好时间复杂度是O(n)平均时间复杂度是根据步长序列的不同而不同
2. 空间复杂度是O(n)
3. 不稳定算法

先将整个待排序的记录序列分割成若干子序列分别进行直接插入排序

- 选择一个增量序列t1,t2,...,tk，其中ti > tj, tk =1
- 按增量序列个数k，对序列进行k趟排序
- 每趟排序，根据对应增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序，仅增量因子为1的时候，整个序列作为一个表来处理，表长度即为整个序列的长度。
- 增量序列的最后一个值一定取1
- 增量序列中的值尽量没有除1之外的公因子

希尔排序是基于插入排序的以下两点性质而提出改进方法的

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

### 起泡排序

起泡排序算法又被称为冒泡算法，是通过一系列的交换动作完成，首先第一个关键字和第二个关键字比较，如果第一个大，则二者交换，否则不叫唤，然后第二个关键字和第三个关键字交换，如果第二个大，则二者交换，以此类推。

## 需要手写的代码

### 数据结构

1. 单链表实现
   1. 插入
   2. 查找
   3. 删除
2. 单链表操作
3. 双链表操作
4. 实现栈和队列
   1. 判断队空/栈空
   2. 判断队满/栈空
   3. 出队/出栈
   4. 入队/入栈
5. 循环队列
6. 队列和栈的进出顺序
7. 中缀表达式转后缀表达式或后缀表达式转中缀

